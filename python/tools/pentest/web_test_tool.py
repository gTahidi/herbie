import asyncio
import json
import aiohttp
from dataclasses import dataclass
from python.helpers.tool import Tool, Response
from python.helpers.print_style import PrintStyle

@dataclass
class State:
    current_target: str = None
    scan_results: dict = None
    vuln_results: dict = None

class WebTestTool(Tool):
    async def execute(self, **kwargs):
        await self.agent.handle_intervention()
        await self.prepare_state()

        action = self.args.get("action", "").lower().strip()
        target = self.args.get("target", "").strip()

        if not target:
            return Response(
                message=self.agent.read_prompt("pentest/web_test_tool_usage.md"),
                break_loop=False
            )

        if action == "scan":
            response = await self.scan_target(target)
        elif action == "test_endpoint":
            response = await self.test_endpoint(target)
        elif action == "fuzz":
            response = await self.fuzz_parameter(target)
        else:
            response = self.agent.read_prompt("pentest/web_test_tool_usage.md")

        return Response(message=response, break_loop=False)

    async def prepare_state(self):
        if not hasattr(self.agent.state, "web_test"):
            self.agent.state.web_test = State()

    async def scan_target(self, target):
        scan_type = self.args.get("scan_type", "basic")
        options = self.args.get("options", {})
        
        results = {
            "target": target,
            "scan_type": scan_type,
            "findings": []
        }

        async with aiohttp.ClientSession() as session:
            # Basic endpoint discovery
            common_endpoints = ["/", "/login", "/admin", "/api", "/register"]
            for endpoint in common_endpoints:
                url = f"{target.rstrip('/')}{endpoint}"
                try:
                    async with session.get(url) as response:
                        results["findings"].append({
                            "endpoint": endpoint,
                            "status": response.status,
                            "headers": dict(response.headers)
                        })
                except Exception as e:
                    results["findings"].append({
                        "endpoint": endpoint,
                        "error": str(e)
                    })

        self.agent.state.web_test.scan_results = results
        return json.dumps(results, indent=2)

    async def test_endpoint(self, target):
        method = self.args.get("method", "GET")
        tests = self.args.get("tests", ["xss", "sqli"])
        data = self.args.get("data", {})

        results = {
            "target": target,
            "method": method,
            "tests": tests,
            "findings": []
        }

        # Example payloads
        payloads = {
            "xss": ["<script>alert(1)</script>", "javascript:alert(1)"],
            "sqli": ["' OR '1'='1", "admin' --"],
            "auth": ["admin:admin", "root:root"]
        }

        async with aiohttp.ClientSession() as session:
            for test_type in tests:
                if test_type in payloads:
                    for payload in payloads[test_type]:
                        test_data = data.copy()
                        for key in test_data:
                            test_data[key] = payload

                        try:
                            if method.upper() == "GET":
                                async with session.get(target, params=test_data) as response:
                                    results["findings"].append({
                                        "test": test_type,
                                        "payload": payload,
                                        "status": response.status
                                    })
                            else:
                                async with session.post(target, data=test_data) as response:
                                    results["findings"].append({
                                        "test": test_type,
                                        "payload": payload,
                                        "status": response.status
                                    })
                        except Exception as e:
                            results["findings"].append({
                                "test": test_type,
                                "payload": payload,
                                "error": str(e)
                            })

        return json.dumps(results, indent=2)

    async def fuzz_parameter(self, target):
        parameter = self.args.get("parameter")
        fuzz_type = self.args.get("fuzz_type", "xss")
        options = self.args.get("options", {})

        if not parameter:
            return "Error: No parameter specified for fuzzing"

        results = {
            "target": target,
            "parameter": parameter,
            "fuzz_type": fuzz_type,
            "findings": []
        }

        # Example fuzzing payloads
        payloads = {
            "xss": [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "javascript:alert(1)"
            ]
        }

        if fuzz_type in payloads:
            async with aiohttp.ClientSession() as session:
                for payload in payloads[fuzz_type]:
                    try:
                        params = {parameter: payload}
                        async with session.get(target, params=params) as response:
                            content = await response.text()
                            results["findings"].append({
                                "payload": payload,
                                "status": response.status,
                                "reflected": payload in content
                            })
                            
                            if options.get("delay"):
                                await asyncio.sleep(options["delay"])
                    except Exception as e:
                        results["findings"].append({
                            "payload": payload,
                            "error": str(e)
                        })

        return json.dumps(results, indent=2)